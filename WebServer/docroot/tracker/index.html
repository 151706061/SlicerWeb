<!DOCTYPE html>
<html>
<head>

  <title>Browser tracking for mobile</title>

  <link rel="stylesheet" href="../stylesheets/application.css" />
  <script src='http://code.jquery.com/jquery-2.0.3.min.js'></script>

</head>

<body>

<div id='videos'> </div>

<script> /* getSources inspired from https://github.com/samdutton/simpl/tree/master/getusermedia */ </script>

<div id="container">

  <h1>Data for tracking</h1>

  <h2>Be sure to approve requests for the camera(s) and microphone(s).</h2>

<span id="video"></span>

<script>

'use strict';

var videoLabel = document.getElementById('video');
videoLabel.innerHTML = "<p> waiting for video events...</p>";


// handle browser differences
navigator.getUserMedia = navigator.getUserMedia ||
  navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

// seems only one video stream can be active at a time, at least
// on chrome on android so we pick the second video source
var skipFirstVideo = true;

// when sources are found
function gotSources(sourceInfos) {
  for (var i = 0; i !== sourceInfos.length; ++i) {
    var sourceInfo = sourceInfos[i];
    if (sourceInfo.kind === 'video') {
      if (!skipFirstVideo) {
        videoLabel.innerHTML = "<p> Found some video </p>";
        videoStart(sourceInfo.id);
      }
      skipFirstVideo = false;
    }
    if (sourceInfo.kind === 'audio') {
      console.log("There's audio available, but we don't care");
    } else {
      console.log('Some other kind of source: ', sourceInfo);
    }
  }
}

// ask for sources
if (typeof MediaStreamTrack.getSources === 'undefined'){
  alert('This browser does not support MediaStreamTrack.\n\nTry Chrome Canary.');
} else {
  MediaStreamTrack.getSources(gotSources);
}

var videoCount = 0;
// play the video when it's available
function videoSuccessCallback(stream) {
  videoCount += 1;
  var videoID = "video"+videoCount;
  $('#videos').append('<video autoplay id='+videoID+'></video><p>'+videoID+'</p>');
  var videoElement = document.querySelector('#video1');
  videoElement.src = window.URL.createObjectURL(stream);
  videoElement.play();
  videoElement.addEventListener('canplay', function(ev){
    var width = 200;
    var height = videoElement.videoHeight / (videoElement.videoWidth/width);
    videoElement.setAttribute('width', width);
    videoElement.setAttribute('height', height);
  }, false);
}

// or error out
function errorCallback(error){
  console.log('navigator.getUserMedia error: ', error);
  videoLabel.innerHTML = "<p> Error Accessing video </p>";
}

// entry point for video
function videoStart(videoSource){
  var constraints = {
    video: {
      optional: [{sourceId: videoSource}]
    }
  };
  console.log('asking for videoSource', videoSource);
  console.log('asking for constraints', constraints);
  navigator.getUserMedia(constraints, videoSuccessCallback, errorCallback);
}

</script>


<span id="orientation"></span>

<script>

// from http://w3c.github.io/deviceorientation/spec-source-orientation.html#deviceorientation

var degtorad = Math.PI / 180; // Degree-to-Radian conversion

function getRotationMatrix( alpha, beta, gamma ) {

  var _x = beta  ? beta  * degtorad : 0; // beta value
  var _y = gamma ? gamma * degtorad : 0; // gamma value
  var _z = alpha ? alpha * degtorad : 0; // alpha value

  var cX = Math.cos( _x );
  var cY = Math.cos( _y );
  var cZ = Math.cos( _z );
  var sX = Math.sin( _x );
  var sY = Math.sin( _y );
  var sZ = Math.sin( _z );

  //
  // ZXY rotation matrix construction.
  //

  var m11 = cZ * cY - sZ * sX * sY;
  var m12 = - cX * sZ;
  var m13 = cY * sZ * sX + cZ * sY;

  var m21 = cY * sZ + cZ * sX * sY;
  var m22 = cZ * cX;
  var m23 = sZ * sY - cZ * cY * sX;

  var m31 = - cX * sY;
  var m32 = sX;
  var m33 = cX * cY;

  return [
    m11,    m12,    m13,
    m21,    m22,    m23,
    m31,    m32,    m33
  ];

};

function matrixTable(m) {
  var t = "<table>";
  for (row = 0; row < 3; row++) {
    t += "<tr>";
    for (column = 0; column < 3; column++) {
      t += "<td>" + m[3*row+column].toFixed(3) + "</td>";
    }
    t += "</tr>";
  }
  t += "</table>";
  return (t);
}

var orientationLabel = document.getElementById('orientation');
orientationLabel.innerHTML = "<p> waiting for orientation events...</p>";


var pendingAjax = undefined;
var currentMatrix = undefined;
var currentEulers = undefined;
var useEulers = true;

// used if sending rotation matrix
var sendTransform = function() {
  if (useEulers) {
    var action = "slicer/eulers?angles=" + String(currentEulers);
  } else {
    var action = "slicer/transform?m=" + String(currentMatrix);
  }

  pendingAjax = $.ajax(action)
  .done(function() {
    sendTransform();
  })
  .fail(function() {
    alert("Could not send transform, aborting");
  });
}

window.addEventListener('deviceorientation', function(e) {
        /* e.alpha, beta: e.beta, gamma: e.gamma */
        var orientationLabel = document.getElementById('orientation');
        orientationLabel.innerHTML = "<p> e = " + e + "</p>";
        orientationLabel.innerHTML += "<p> alpha = " + e.alpha + "</p>";
        orientationLabel.innerHTML += "<p> beta = " + e.beta + "</p>";
        orientationLabel.innerHTML += "<p> gamma = " + e.gamma + "</p>";
        orientationLabel.innerHTML += "<p> absolute = " + e.absolute + "</p>";

        currentEulers = [e.alpha, e.beta, e.gamma];

        currentMatrix = getRotationMatrix(e.alpha, e.beta, e.gamma);

        if (pendingAjax === undefined) {
          sendTransform();
        }

        orientationLabel.innerHTML += "<p> " + matrixTable(currentMatrix);

}, true);

</script>


  <p>This demo uses advanced web apis to access sensors.  Not all devices and browsers are supported.</p>

</div>


</body>
</html>
